<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>D&D Terminal</title>
<link rel="stylesheet" href="frontend/crt.css">
</head>
<body>

<div id="terminal-container" style="display:none;">
    <pre id="terminal"></pre>
</div>

<div id="controls">
    <input id="gameId" placeholder="Enter game ID">
    <button id="hostBtn">Host Game</button>
    <button id="joinBtn">Join Game</button>
</div>

<script type="module">
// ===================== IMPORT HELPERS =====================
import { logTerminal, clearTerminal, showHelp, showTutorial } from "./frontend/cli_helper.js";

const termContainer = document.getElementById("terminal-container");
const term = document.getElementById("terminal");

function log(msg, options={}) {
    logTerminal(term, msg, options);
    term.scrollTop = term.scrollHeight;
}
function clear() { clearTerminal(term); }

// ===================== PYODIDE =====================
let pyodideReady = false;
let pyodide;

async function initPyodide(){
    try {
        log("Loading Pyodide...");
        pyodide = await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"});
        pyodideReady = true;
        log("Pyodide ready.\n");

        await pyodide.runPythonAsync(`
import sys
sys.path.insert(0,"dnd_engine")
import engine
`);
        log("Engine loaded.\n");

        const asciiResponse = await fetch("frontend/ascii.txt");
        const asciiArt = await asciiResponse.text();
        log(asciiArt, {highlight:true});
        scaleAscii();
    } catch(err){
        log("Pyodide failed: "+err);
    }
}

import("https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.mjs")
    .then(() => initPyodide());

// ===================== WEBRTC =====================
let pc, dataChannel, isHost = false;
let iceCandidates = [];

function setupPeerConnection(){
    pc = new RTCPeerConnection();
    pc.onicecandidate = e => { 
        if(e.candidate) iceCandidates.push(e.candidate); 
    };
}

document.getElementById("hostBtn").onclick = async () => {
    if(!pyodideReady) return log("Pyodide not ready");
    isHost = true;
    termContainer.style.display = "block";
    clear();
    log("Hosting game...\n", {highlight:true});
    document.getElementById("controls").style.display="none";

    setupPeerConnection();
    dataChannel = pc.createDataChannel("dnd");
    dataChannel.onmessage = e => handleMessage(e.data);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    const gameId = btoa(JSON.stringify(offer));
    log("=== HOST GAME ID (Base64) ===", {highlight:true});
    log(gameId, {highlight:true});
    log("============================\n", {highlight:true});

    showHelp(term, true);
};

document.getElementById("joinBtn").onclick = async () => {
    if(!pyodideReady) return log("Pyodide not ready");
    const gameIdInput = document.getElementById("gameId").value.trim();
    if(!gameIdInput) return log("Enter a game ID first!");
    termContainer.style.display = "block";
    clear();
    log("Joining game...\n", {highlight:true});
    document.getElementById("controls").style.display="none";

    const offer = JSON.parse(atob(gameIdInput));
    setupPeerConnection();
    pc.ondatachannel = ev => {
        dataChannel = ev.channel;
        dataChannel.onmessage = e => handleMessage(e.data);
    };

    await pc.setRemoteDescription(offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    const answerId = btoa(JSON.stringify(answer));
    log("=== JOINED GAME ===\nBase64 Answer ID (send to host):\n"+answerId, {highlight:true});
    showHelp(term, false);
};

// ===================== TERMINAL INPUT =====================
const cmdInput = document.createElement("input");
cmdInput.placeholder = "Type command here...";
Object.assign(cmdInput.style,{
    width:"90%", background:"#111", color:"#0f0", border:"1px solid #0f0",
    borderRadius:"8px", fontFamily:"'VT323', monospace", fontSize:"1.1em", marginTop:"10px"
});
termContainer.appendChild(cmdInput);
cmdInput.focus();

cmdInput.addEventListener("keydown", async e => {
    if(e.key !== "Enter") return;
    const cmd = e.target.value.trim();
    e.target.value = "";
    if(!cmd) return;
    log("> "+cmd);
    handleCommand(cmd);
});

// ===================== MESSAGE HANDLER =====================
function handleMessage(msg){
    log("[REMOTE] "+msg);
}

// ===================== CHARACTER CREATION =====================
async function createCharFlow(charName){
    if(!pyodideReady) return log("Pyodide not ready");

    function getInput(promptText){
        return new Promise(resolve => {
            log(promptText, {highlight:true});
            cmdInput.disabled = false;

            const handler = e => {
                if(e.key !== "Enter") return;
                const val = e.target.value.trim();
                if(!val) return;
                e.target.value = "";
                cmdInput.removeEventListener("keydown", handler);
                cmdInput.disabled = true;
                resolve(val);
            };
            cmdInput.addEventListener("keydown", handler);
        });
    }

    try{
        const race = await getInput("Enter Race (SRD/homebrew):");

        let classesList;
        while(true){
            const classesInput = await getInput("Enter Classes (comma-separated):");
            classesList = classesInput.split(",").map(c=>c.trim()).filter(Boolean);
            if(classesList.length > 0) break;
            log("Invalid input. Must enter at least one class.");
        }

        const levelsList = [];
        for(const cls of classesList){
            while(true){
                const lvlInput = await getInput(`Enter level for ${cls}:`);
                const lvl = parseInt(lvlInput);
                if(!isNaN(lvl) && lvl >=1){
                    levelsList.push(lvl);
                    break;
                }
                log("Invalid level. Must be integer >=1");
            }
        }

        const abilityChoice = (await getInput("Assign abilities: roll or manual?")).toLowerCase();
        const abilities = {};
        if(abilityChoice==="roll"){
            await pyodide.runPythonAsync(`
import random
abilities = {s:sum(sorted([random.randint(1,6) for _ in range(4)])[1:]) for s in ["STR","DEX","CON","INT","WIS","CHA"]}
`);
            const pyAbilities = await pyodide.globals.get("abilities");
            Object.assign(abilities, pyAbilities.toJs());
        } else {
            for(const stat of ["STR","DEX","CON","INT","WIS","CHA"]){
                while(true){
                    const val = parseInt(await getInput(`Enter value for ${stat}:`));
                    if(!isNaN(val)){
                        abilities[stat] = val;
                        break;
                    }
                    log("Must enter integer.");
                }
            }
        }

        const pyCmd = `
import json, base64
from engine import Character, get_race, get_class

c = Character("${charName}", get_race("${race}"), "${classesList[0]}")
c.classes = dict(zip(${JSON.stringify(classesList)}, ${JSON.stringify(levelsList)}))
c.level = sum(${JSON.stringify(levelsList)})
c.abilities = ${JSON.stringify(abilities)}
c.hit_dice = [c.get_class(cls).get("hit_die",8) for cls in ${JSON.stringify(classesList)} for _ in range(${JSON.stringify(levelsList)}[${JSON.stringify(classesList)}.index(cls)])]
c.spell_slots = {}
base64_str = base64.b64encode(json.dumps(c.__dict__).encode()).decode()
base64_str
`;
        const b64 = await pyodide.runPythonAsync(pyCmd);
        log("Character created! Copy this Base64 string to load later:\n"+b64, {highlight:true});

    } catch(err){ log("Error during character creation: "+err); }
}

// ===================== LOAD CHARACTER =====================
async function loadChar(b64){
    if(!pyodideReady) return log("Pyodide not ready");
    try{
        const pyCmd = `
import json, base64
data=json.loads(base64.b64decode("${b64}").decode())
data
`;
        const loaded = await pyodide.runPythonAsync(pyCmd);
        log("--- Character Loaded ---", {highlight:true});
        for(const [k,v] of Object.entries(loaded)){
            log(`${k}: ${typeof v === "object" ? JSON.stringify(v) : v}`);
        }
    } catch(err){ log("Error loading character: "+err); }
}

// ===================== COMMAND HANDLER =====================
async function handleCommand(cmd){
    if(!pyodideReady) return log("Pyodide not ready");

    try{
        if(cmd.startsWith("/help")){
            showHelp(term, isHost);
        } else if(cmd.startsWith("/tut")){
            showTutorial(term, isHost, dataChannel);
        } else if(cmd.startsWith("/create_char")){
            const parts = cmd.split(" ");
            const charName = parts[1];
            if(!charName) return log("Usage: /create_char CHAR_NAME");
            await createCharFlow(charName);

        } else if(cmd.startsWith("/load_char")){
            const b64 = cmd.split(" ")[1];
            if(!b64) return log("Usage: /load_char BASE64_STRING");
            await loadChar(b64);

        } else {
            let res = await pyodide.runPythonAsync(cmd);
            if(res !== undefined) log(String(res));
        }

        if(dataChannel && dataChannel.readyState==="open") dataChannel.send(cmd);

    } catch(err){ log("Error: "+err); }
}

// ===================== ASCII SCALING =====================
window.addEventListener("resize", scaleAscii);
function scaleAscii(){
    if(!term.textContent) return;
    term.style.fontSize = Math.min(window.innerWidth/150, window.innerHeight/75) + "px";
}
</script>
</body>
</html>
