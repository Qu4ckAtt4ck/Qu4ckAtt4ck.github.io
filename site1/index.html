<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DND Full Online</title>
<link rel="stylesheet" href="frontend/crt.css">
</head>
<body>

<!-- TERMINAL -->
<div id="terminal-container">
    <div id="cmd-container">
        <div id="terminal-wrapper">
            <div id="terminal"></div>
        </div>
        <input id="cli-input" placeholder="Type command here...">
    </div>
</div>

<!-- LANDING PAGE -->
<div id="controls">
    <input id="gameId" placeholder="Enter game ID">
    <button id="hostBtn">Host Game</button>
    <button id="joinBtn">Join Game</button>
</div>

<script type="module">
import { logTerminal, clearTerminal, showHelp, createCharInteractive } from "frontend/cli_helper.js";

const termContainer = document.getElementById("terminal-container");
const term = document.getElementById("terminal");
const controls = document.getElementById("controls");
const wrapper = document.getElementById("terminal-wrapper");
const cmdInput = document.getElementById("cli-input");

function log(msg, options={}) { logTerminal(term, msg, options); }

// ===== FETCH ASCII =====
async function getASCII() {
    try {
        const resp = await fetch("frontend/ascii.txt");
        if (!resp.ok) throw new Error("ASCII file not found");
        return await resp.text();
    } catch (err) {
        log("Failed to load ASCII: " + err);
        return "";
    }
}

// ===== LOCKED CRT MODE =====
async function enterTerminalMode() {
    controls.style.display = "none";
    termContainer.style.display = "flex";
    document.body.style.overflow = "hidden";
    document.body.style.userSelect = "none";
    if (!document.fullscreenElement) {
        try { await document.documentElement.requestFullscreen(); } catch {}
    }
    cmdInput.focus();
}

// ===== PYODIDE =====
let pyodideReady = false;
async function initPyodide() {
    log("Loading Pyodide...");
    window.pyodide = await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"});
    pyodideReady = true;

    await pyodide.runPythonAsync(`
import sys, json, base64
sys.path.insert(0,"dnd_engine")
import engine

combat = engine.Combat()
dm = engine.DM(combat)
characters = {}

# Character creation helper for full multiclass + homebrew
def create_char_full(name,race,classes,abilities=None,hp=None,hit_dice=None,conditions=None,spell_slots=None,homebrew=None):
    char = engine.Character(name,race,list(classes.keys())[0])
    char.classes = classes
    if abilities: char.abilities = abilities
    if hp: char.hp = hp
    if hit_dice: char.hit_dice = hit_dice
    if conditions: char.conditions = conditions
    if spell_slots: char.spell_slots = spell_slots
    if homebrew: char.homebrew_features = homebrew
    characters[name] = char
    return char

def save_char(name):
    if name not in characters: return "Character not found"
    char = characters[name]
    data = {
        "name": char.name,
        "race": char.race.data,
        "classes": char.classes,
        "level": sum(char.classes.values()),
        "hp": char.hp,
        "hit_dice": char.hit_dice,
        "abilities": char.abilities,
        "conditions": char.conditions,
        "spell_slots": char.spell_slots,
        "homebrew_features": getattr(char,"homebrew_features",{})
    }
    return base64.b64encode(json.dumps(data).encode()).decode()

def load_char(encoded):
    data = json.loads(base64.b64decode(encoded))
    return create_char_full(
        data['name'], data['race']['id'], data['classes'], data['abilities'],
        data['hp'], data['hit_dice'], data['conditions'], data['spell_slots'],
        data.get('homebrew_features',{})
    )

# Tutorials
def tut(isDM=False):
    if isDM:
        return """DM Tutorial:
- /roll XdY
- /list monsters/spells/classes
- /create_char
- /set_hp /damage /heal /add_cond /remove_cond
- /next_turn
- /save_char NAME
- /load_char BASE64
- /tut
"""
    else:
        return """Player Tutorial:
- /roll XdY
- /cast SPELL [target]
- /create_char
- /save_char NAME
- /load_char BASE64
- /help
"""

# Automated turn
def advanceTurn():
    return combat.next_turn()
`);
    log("Engine loaded.\n");
}

const pyScript = document.createElement("script");
pyScript.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
pyScript.onload = initPyodide;
document.body.appendChild(pyScript);

// ===== WEBRTC =====
let pc, dataChannel;

// ===== SCALE ASCII PROPORTIONALLY =====
function scaleASCII() {
    const asciiText = term.textContent.split("\n");
    const originalWidth = 145;
    const originalHeight = asciiText.length;

    function applyScale() {
        const vw = window.innerWidth - 40;
        const vh = window.innerHeight - 120;
        const fontWidth = 0.6;
        const fontHeight = 1;
        const scaleX = vw / (originalWidth * fontWidth * 16);
        const scaleY = vh / (originalHeight * fontHeight * 16);
        const scale = Math.min(scaleX, scaleY);
        wrapper.style.transform = `scale(${scale})`;
        const wrapperHeight = originalHeight * 16 * scale;
        const containerHeight = window.innerHeight - 40;
        const topMargin = Math.max((containerHeight - wrapperHeight - 40)/2, 0);
        wrapper.style.marginTop = topMargin + "px";
    }

    window.addEventListener("resize", applyScale);
    applyScale();
}

// ===== HOST GAME =====
async function startHost() {
    if (!pyodideReady) return log("Engine not ready.");
    await enterTerminalMode();
    clearTerminal(term);

    log("Booting WebRTC host...");
    const ascii = await getASCII();
    if (ascii) { log(ascii, {highlight:true}); scaleASCII(); }

    pc = new RTCPeerConnection();
    dataChannel = pc.createDataChannel("dnd");
    dataChannel.onmessage = async e => {
        log("[CLIENT] " + e.data);
        if (!pyodideReady) return;
        try {
            const res = await pyodide.runPythonAsync(e.data);
            if (res !== undefined) log(String(res));
        } catch(err){ log("Error: "+err); }
        if (dataChannel.readyState === "open") dataChannel.send(`HOST UPDATE: ${e.data}`);
    };
    pc.onicecandidate = e => { if (e.candidate) log("ICE Candidate: "+JSON.stringify(e.candidate)); };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const encoded = btoa(JSON.stringify(offer));
    log("Host ready.");
    log("=== BASE64 GAME ID ===", {highlight:true});
    log(encoded, {highlight:true});
    log("=====================", {highlight:true});

    showHelp(term, true);
}

// ===== JOIN GAME =====
async function joinGame() {
    if (!pyodideReady) return log("Engine not ready.");
    await enterTerminalMode();
    clearTerminal(term);

    const gameId = document.getElementById("gameId").value.trim();
    if (!gameId) return log("Enter a game ID first!");

    log("Connecting to host...");
    const ascii = await getASCII();
    if (ascii) { log(ascii, {highlight:true}); scaleASCII(); }

    const offer = JSON.parse(atob(gameId));
    pc = new RTCPeerConnection();
    pc.ondatachannel = ev => {
        dataChannel = ev.channel;
        dataChannel.onmessage = e => log("[HOST] " + e.data);
    };
    pc.onicecandidate = e => { if (e.candidate) log("ICE Candidate: "+JSON.stringify(e.candidate)); };

    await pc.setRemoteDescription(offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    log("Connected to host.");
    showHelp(term, false);
}

// ===== /TUT COMMAND =====
async function runTutorial(isDM=false) {
    if (!pyodideReady) return;
    const tutText = await pyodide.runPythonAsync(`tut(${isDM})`);
    log(tutText, {highlight:true});
    if (dataChannel?.readyState==="open" && isDM) {
        const playerTut = await pyodide.runPythonAsync("tut(False)");
        dataChannel.send(playerTut);
    }
}

// ===== BUTTONS =====
document.getElementById("hostBtn").onclick = startHost;
document.getElementById("joinBtn").onclick = joinGame;

// ===== CLI INPUT =====
cmdInput.addEventListener("keydown", async e => {
    if (e.key !== "Enter") return;
    const cmd = cmdInput.value.trim();
    cmdInput.value = "";

    log("> " + cmd);

    if (pyodideReady) {
        try {
            if (cmd.startsWith("/create_char")) {
                createCharInteractive(term, pyodide, dataChannel);
                return;
            }
            if (cmd.startsWith("/tut")) { 
                await runTutorial(true); 
                return;
            }
            if (cmd.startsWith("/next_turn")) {
                const res = await pyodide.runPythonAsync("advanceTurn()");
                log(res, {highlight:true});
                if(dataChannel?.readyState==="open") dataChannel.send(res);
                return;
            }
            const res = await pyodide.runPythonAsync(cmd);
            if (res!==undefined) log(String(res));
        } catch(err){ log("Error: "+err); }
    }

    if (dataChannel?.readyState === "open") dataChannel.send(cmd);
});

// Focus CLI input on click
termContainer.addEventListener("click", () => cmdInput.focus());
termContainer.addEventListener("mousedown", e => e.preventDefault());
</script>

</body>
</html>
