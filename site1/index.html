<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DND Full Online</title>
<link rel="stylesheet" href="frontend/crt.css">
</head>
<body>

<!-- TERMINAL -->
<div id="terminal-container">
    <div id="cmd-container">
        <div id="terminal-wrapper">
            <div id="terminal"></div>
        </div>
        <input id="cli-input" placeholder="Type command here...">
    </div>
</div>

<!-- LANDING PAGE -->
<div id="controls">
    <input id="gameId" placeholder="Enter game ID">
    <button id="hostBtn">Host Game</button>
    <button id="joinBtn">Join Game</button>
</div>

<script type="module">
import { logTerminal, clearTerminal, showHelp } from "frontend/cli_helper.js";

const termContainer = document.getElementById("terminal-container");
const term = document.getElementById("terminal");
const controls = document.getElementById("controls");
const wrapper = document.getElementById("terminal-wrapper");
const cmdInput = document.getElementById("cli-input");

function log(msg, options={}) { logTerminal(term, msg, options); }

// ===== FETCH ASCII =====
async function getASCII() {
    try {
        const resp = await fetch("frontend/ascii.txt");
        if (!resp.ok) throw new Error("ASCII file not found");
        return await resp.text();
    } catch (err) {
        log("Failed to load ASCII: " + err);
        return "";
    }
}

// ===== LOCKED CRT MODE =====
async function enterTerminalMode() {
    controls.style.display = "none";
    termContainer.style.display = "flex";

    document.body.style.overflow = "hidden";
    document.body.style.userSelect = "none";

    if (!document.fullscreenElement) {
        try { await document.documentElement.requestFullscreen(); } catch {}
    }

    cmdInput.focus();
}

// ===== PYODIDE =====
let pyodideReady = false;
async function initPyodide() {
    log("Loading Pyodide...");
    window.pyodide = await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"});
    pyodideReady = true;

    await pyodide.runPythonAsync(`
import sys, json, base64
sys.path.insert(0,"dnd_engine")
import engine
combat = engine.Combat()
dm = engine.DM(combat)
characters = {}

def create_char_full(name,race,classes,level=1,abilities=None,hp=None,hit_dice=None,conditions=None,spell_slots=None,homebrew=None):
    char = engine.Character(name,race,list(classes.keys())[0],level)
    char.classes = classes
    if abilities: char.abilities = abilities
    if hp: char.hp = hp
    if hit_dice: char.hit_dice = hit_dice
    if conditions: char.conditions = conditions
    if spell_slots: char.spell_slots = spell_slots
    if homebrew: char.homebrew_features = homebrew
    characters[name] = char
    return char

def save_char(name):
    if name not in characters: return "Character not found"
    char = characters[name]
    data = {
        "name": char.name,
        "race": char.race.data,
        "classes": char.classes,
        "level": char.level,
        "hp": char.hp,
        "hit_dice": char.hit_dice,
        "abilities": char.abilities,
        "conditions": char.conditions,
        "spell_slots": char.spell_slots,
        "homebrew_features": getattr(char,"homebrew_features",{})
    }
    return base64.b64encode(json.dumps(data).encode()).decode()

def load_char(encoded):
    data = json.loads(base64.b64decode(encoded))
    return create_char_full(data['name'], data['race']['id'], data['classes'], data['level'],
                            data['abilities'], data['hp'], data['hit_dice'], data['conditions'], data['spell_slots'],
                            data.get('homebrew_features',{}))

def tut(isDM=False):
    if isDM:
        return """DM Tutorial:
- /roll XdY: Roll dice
- /list monsters/spells/classes: Show entities
- /create_char: Step-by-step full character creation
- /set_hp /damage /heal /add_cond /remove_cond: Manage combat
- /next_turn: Advance combat
- /tut: Show this tutorial
- /save_char NAME: Get Base64 save string
- /load_char BASE64: Load saved character
"""
    else:
        return """Player Tutorial:
- /roll XdY: Roll dice
- /cast SPELL [target]: Cast spell
- /create_char: Step-by-step character creation
- /save_char NAME: Copy Base64 save string
- /load_char BASE64: Load saved character
- /help: Show commands
"""
`);
    log("Engine loaded.\n");
}

const pyScript = document.createElement("script");
pyScript.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
pyScript.onload = initPyodide;
document.body.appendChild(pyScript);

// ===== WEBRTC =====
let pc, dataChannel;

// ===== SCALE ASCII PROPORTIONALLY =====
function scaleASCII() {
    const asciiText = term.textContent.split("\n");
    const originalWidth = 145;
    const originalHeight = asciiText.length;

    function applyScale() {
        const vw = window.innerWidth - 40;
        const vh = window.innerHeight - 120;
        const fontWidth = 0.6;
        const fontHeight = 1;

        const scaleX = vw / (originalWidth * fontWidth * 16);
        const scaleY = vh / (originalHeight * fontHeight * 16);
        const scale = Math.min(scaleX, scaleY);

        wrapper.style.transform = `scale(${scale})`;

        const wrapperHeight = originalHeight * 16 * scale;
        const containerHeight = window.innerHeight - 40;
        const topMargin = Math.max((containerHeight - wrapperHeight - 40)/2, 0);
        wrapper.style.marginTop = topMargin + "px";
    }

    window.addEventListener("resize", applyScale);
    applyScale();
}

// ===== HOST GAME =====
async function startHost() {
    if (!pyodideReady) return log("Engine not ready.");
    await enterTerminalMode();
    clearTerminal(term);

    log("Booting WebRTC host...");

    const ascii = await getASCII();
    if (ascii) { log(ascii, {highlight:true}); scaleASCII(); }

    pc = new RTCPeerConnection();
    dataChannel = pc.createDataChannel("dnd");
    dataChannel.onmessage = async e => {
        log("[CLIENT] " + e.data);
        if (!pyodideReady) return;
        try {
            const res = await pyodide.runPythonAsync(e.data);
            if (res !== undefined) log(String(res));
        } catch(err){ log("Error: "+err); }
        if (dataChannel.readyState === "open") dataChannel.send(`HOST UPDATE: ${e.data}`);
    };
    pc.onicecandidate = e => { if (e.candidate) log("ICE Candidate: "+JSON.stringify(e.candidate)); };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const encoded = btoa(JSON.stringify(offer));
    log("Host ready.");
    log("=== BASE64 GAME ID ===", {highlight:true});
    log(encoded, {highlight:true});
    log("=====================", {highlight:true});

    showHelp(term, true); // DM sees full commands
}

// ===== JOIN GAME =====
async function joinGame() {
    if (!pyodideReady) return log("Engine not ready.");
    await enterTerminalMode();
    clearTerminal(term);

    const gameId = document.getElementById("gameId").value.trim();
    if (!gameId) return log("Enter a game ID first!");

    log("Connecting to host...");

    const ascii = await getASCII();
    if (ascii) { log(ascii, {highlight:true}); scaleASCII(); }

    const offer = JSON.parse(atob(gameId));
    pc = new RTCPeerConnection();
    pc.ondatachannel = ev => {
        dataChannel = ev.channel;
        dataChannel.onmessage = e => log("[HOST] " + e.data);
    };
    pc.onicecandidate = e => { if (e.candidate) log("ICE Candidate: "+JSON.stringify(e.candidate)); };

    await pc.setRemoteDescription(offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    log("Connected to host.");
    showHelp(term, false); // player sees player commands
}

// ===== AUTOMATED COMBAT TURN =====
async function advanceTurn() {
    if (!pyodideReady) return;
    try {
        const next = await pyodide.runPythonAsync("combat.next_turn()");
        log("=== Next Turn: " + next + " ===", {highlight:true});
        if (dataChannel?.readyState === "open") dataChannel.send(`/turn ${next}`);
    } catch(err){ log("Error advancing turn: " + err); }
}

// ===== /TUT COMMAND =====
async function runTutorial(isDM=false) {
    if (!pyodideReady) return;
    const tutText = await pyodide.runPythonAsync(`tut(${isDM})`);
    log(tutText, {highlight:true});
    if (dataChannel && dataChannel.readyState === "open" && isDM) {
        // broadcast player tutorial
        const playerTut = await pyodide.runPythonAsync("tut(False)");
        dataChannel.send(playerTut);
    }
}

// ===== BUTTONS =====
document.getElementById("hostBtn").onclick = startHost;
document.getElementById("joinBtn").onclick = joinGame;

// ===== CLI INPUT =====
cmdInput.addEventListener("keydown", async e => {
    if (e.key !== "Enter") return;
    const cmd = cmdInput.value.trim();
    cmdInput.value = "";

    log("> " + cmd);

    if (pyodideReady) {
        try {
            // Special commands
            if(cmd.startsWith("/tut")) { 
                await runTutorial(true); 
                return;
            }
            const res = await pyodide.runPythonAsync(cmd);
            if (res!==undefined) log(String(res));
        } catch(err){ log("Error: "+err); }
    }

    if (dataChannel?.readyState === "open") dataChannel.send(cmd);
});

// Focus CLI input on click
termContainer.addEventListener("click", () => cmdInput.focus());
termContainer.addEventListener("mousedown", e => e.preventDefault());
</script>

</body>
</html>
