<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Snake Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            background-color: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
        }
        
        canvas {
            border: 3px solid #333;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #111;
            max-width: 100%;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-top: 15px;
            padding: 10px 15px;
            background-color: #333;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
            max-width: 600px;
        }
        
        .button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .button:hover {
            background-color: #3e8e41;
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .settings {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
            max-width: 600px;
            padding: 15px;
            background-color: #333;
            border-radius: 5px;
        }
        
        .setting {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .setting label {
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        select, input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #222;
            color: white;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        .game-over h2 {
            font-size: 3rem;
            color: #FF5252;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .game-over p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }
        
        .mobile-controls {
            display: none;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
            margin-top: 20px;
        }
        
        .mobile-button {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }
        
        #up-button { grid-area: up; }
        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #down-button { grid-area: down; }
        
        .powerup-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .powerup-icon {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            opacity: 0.5;
            font-size: 18px;
        }
        
        .powerup-icon.active {
            opacity: 1;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #speed-boost-icon { background-color: #1E90FF; }
        #shield-icon { background-color: #FFD700; }
        #ghost-icon { background-color: #9370DB; }
        #shrink-icon { background-color: #FF6347; }
        
        #powerup-timer {
            margin-left: 5px;
            font-size: 0.9rem;
        }
        
        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .help-content {
            background-color: #333;
            padding: 30px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* Media queries for responsive design */
        @media (max-width: 768px) {
            canvas {
                max-width: 100%;
                height: auto;
            }
            
            .mobile-controls {
                display: grid;
            }
            
            .game-info, .controls, .settings {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Snake Game</h1>
    </header>
    
    <div class="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div class="game-info">
            <div class="stats">
                <div class="stat">
                    <span class="stat-label">Score</span>
                    <span id="score" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">High Score</span>
                    <span id="high-score" class="stat-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Level</span>
                    <span id="level" class="stat-value">1</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Speed</span>
                    <span id="speed" class="stat-value">1x</span>
                </div>
            </div>
            
            <div class="powerup-display">
                <div id="speed-boost-icon" class="powerup-icon">S</div>
                <div id="shield-icon" class="powerup-icon">P</div>
                <div id="ghost-icon" class="powerup-icon">G</div>
                <div id="shrink-icon" class="powerup-icon">-</div>
                <span id="powerup-timer"></span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-button" class="button">Start Game</button>
            <button id="pause-button" class="button">Pause</button>
            <button id="restart-button" class="button">Restart</button>
            <button id="help-button" class="button">Help</button>
        </div>
        
        <div class="settings">
            <div class="setting">
                <label for="difficulty">Difficulty</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <div class="setting">
                <label for="snake-color">Snake Color</label>
                <input type="color" id="snake-color" value="#4CAF50">
            </div>
            <div class="setting">
                <label for="food-color">Food Color</label>
                <input type="color" id="food-color" value="#FF0000">
            </div>
        </div>
        
        <div class="mobile-controls">
            <div id="up-button" class="mobile-button">⬆️</div>
            <div id="left-button" class="mobile-button">⬅️</div>
            <div id="right-button" class="mobile-button">➡️</div>
            <div id="down-button" class="mobile-button">⬇️</div>
        </div>
    </div>
    
    <div id="game-over" class="game-over">
        <h2>Game Over!</h2>
        <p id="final-score">Score: 0</p>
        <button id="play-again" class="button">Play Again</button>
    </div>
    
    <div id="help-modal" class="help-modal">
        <div class="help-content">
            <button id="close-help" class="close-button">✕</button>
            <h2>How to Play</h2>
            <ul>
                <li><strong>Objective:</strong> Eat food to grow your snake and increase your score</li>
                <li><strong>Controls:</strong> Use arrow keys, WASD, or swipe (on mobile) to control the snake</li>
                <li><strong>Game Over:</strong> Game ends if you hit a wall, obstacle, or your own body</li>
            </ul>
            <h3>Power-ups</h3>
            <ul>
                <li><strong>Speed Boost (S):</strong> Temporarily increases your snake's speed</li>
                <li><strong>Shield (P):</strong> Protects from one collision</li>
                <li><strong>Ghost (G):</strong> Allows passing through walls</li>
                <li><strong>Shrink (-):</strong> Reduces your snake's length</li>
            </ul>
            <h3>Levels</h3>
            <p>Every 10 points, you'll level up. Each level increases the game speed and adds more obstacles.</p>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        class Snake {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Game settings
                this.gridSize = options.gridSize || 20;
                this.snakeColor = options.snakeColor || '#4CAF50';
                this.foodColor = options.foodColor || '#FF0000';
                this.speed = options.speed || 150;
                this.initialSpeed = this.speed;
                this.difficulty = options.difficulty || 'medium';
                
                // Calculate grid dimensions
                this.gridWidth = Math.floor(canvas.width / this.gridSize);
                this.gridHeight = Math.floor(canvas.height / this.gridSize);
                
                // Game state
                this.snake = [];
                this.direction = 'right';
                this.nextDirection = 'right';
                this.food = null;
                this.obstacles = [];
                this.powerUps = [];
                this.activePowerUps = {
                    speedBoost: 0,
                    shield: 0,
                    ghost: 0,
                    shrink: 0
                };
                
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
                this.level = 1;
                this.pointsToNextLevel = 10;
                
                this.gameInterval = null;
                this.isGameOver = false;
                this.isPaused = false;
                
                // DOM elements
                this.scoreElement = document.getElementById('score');
                this.highScoreElement = document.getElementById('high-score');
                this.levelElement = document.getElementById('level');
                this.speedElement = document.getElementById('speed');
                this.gameOverElement = document.getElementById('game-over');
                this.finalScoreElement = document.getElementById('final-score');
                this.powerupIndicator = document.getElementById('powerup-indicator');
                this.powerupTimer = document.getElementById('powerup-timer');
                
                // Power-up icons
                this.speedBoostIcon = document.getElementById('speed-boost-icon');
                this.shieldIcon = document.getElementById('shield-icon');
                this.ghostIcon = document.getElementById('ghost-icon');
                this.shrinkIcon = document.getElementById('shrink-icon');
                
                // Initialize the game
                this.init();
            }
            
            init() {
                // Set canvas dimensions
                this.canvas.width = this.gridWidth * this.gridSize;
                this.canvas.height = this.gridHeight * this.gridSize;
                
                // Initialize snake
                this.snake = [
                    { x: 3, y: Math.floor(this.gridHeight / 2) },
                    { x: 2, y: Math.floor(this.gridHeight / 2) },
                    { x: 1, y: Math.floor(this.gridHeight / 2) }
                ];
                
                // Initialize game state
                this.direction = 'right';
                this.nextDirection = 'right';
                this.score = 0;
                this.level = 1;
                this.pointsToNextLevel = 10;
                this.isGameOver = false;
                this.isPaused = false;
                this.obstacles = [];
                this.powerUps = [];
                this.activePowerUps = {
                    speedBoost: 0,
                    shield: 0,
                    ghost: 0,
                    shrink: 0
                };
                
                // Generate initial food and obstacles
                this.generateFood();
                this.updateScoreDisplay();
                this.adjustDifficulty();
                
                // Hide game over screen
                this.gameOverElement.style.display = 'none';
                
                // Clear any existing game interval
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                    this.gameInterval = null;
                }
                
                // Draw initial state
                this.draw();
            }
            
            start() {
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                }
                this.gameInterval = setInterval(() => {
                    if (!this.isPaused && !this.isGameOver) {
                        this.update();
                        this.draw();
                    }
                }, this.speed);
                // Update pause button text when game starts
                const pauseButton = document.getElementById('pause-button');
                if (pauseButton) {
                    pauseButton.textContent = 'Pause';
                }
            }
            
            pause() {
                this.isPaused = !this.isPaused;
                return this.isPaused;
            }
            
            reset() {
                this.init();
                this.start();
            }
            
            update() {
                // Update direction
                this.direction = this.nextDirection;
                
                // Calculate new head position
                const head = { ...this.snake[0] };
                
                switch (this.direction) {
                    case 'up':
                        head.y -= 1;
                        break;
                    case 'down':
                        head.y += 1;
                        break;
                    case 'left':
                        head.x -= 1;
                        break;
                    case 'right':
                        head.x += 1;
                        break;
                }
                
                // Check for wall collision
                if (!this.activePowerUps.ghost) {
                    if (head.x < 0 || head.x >= this.gridWidth || head.y < 0 || head.y >= this.gridHeight) {
                        if (this.activePowerUps.shield > 0) {
                            this.activePowerUps.shield = 0;
                            this.updatePowerUpIndicators();
                            // Wrap around instead of game over
                            if (head.x < 0) head.x = this.gridWidth - 1;
                            if (head.x >= this.gridWidth) head.x = 0;
                            if (head.y < 0) head.y = this.gridHeight - 1;
                            if (head.y >= this.gridHeight) head.y = 0;
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                } else {
                    // Ghost mode - wrap around
                    if (head.x < 0) head.x = this.gridWidth - 1;
                    if (head.x >= this.gridWidth) head.x = 0;
                    if (head.y < 0) head.y = this.gridHeight - 1;
                    if (head.y >= this.gridHeight) head.y = 0;
                }
                
                // Check for obstacle collision
                for (const obstacle of this.obstacles) {
                    if (head.x === obstacle.x && head.y === obstacle.y) {
                        if (this.activePowerUps.shield > 0) {
                            this.activePowerUps.shield = 0;
                            this.updatePowerUpIndicators();
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                }
                
                // Check for self collision
                for (let i = 1; i < this.snake.length; i++) {
                    if (head.x === this.snake[i].x && head.y === this.snake[i].y) {
                        if (this.activePowerUps.shield > 0) {
                            this.activePowerUps.shield = 0;
                            this.updatePowerUpIndicators();
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                }
                
                // Check for food collision
                let ateFood = false;
                if (this.food && head.x === this.food.x && head.y === this.food.y) {
                    this.score++;
                    ateFood = true;
                    this.generateFood();
                    this.updateScoreDisplay();
                    
                    // Check for level up
                    if (this.score >= this.pointsToNextLevel) {
                        this.levelUp();
                    }
                }
                
                // Check for power-up collision
                for (let i = 0; i < this.powerUps.length; i++) {
                    const powerUp = this.powerUps[i];
                    if (head.x === powerUp.x && head.y === powerUp.y) {
                        this.activatePowerUp(powerUp.type);
                        this.powerUps.splice(i, 1);
                        break;
                    }
                }
                
                // Move snake
                this.snake.unshift(head);
                if (!ateFood) {
                    this.snake.pop();
                }
                
                // Update power-up timers
                this.updatePowerUps();
            }
            
            updatePowerUps() {
                // Decrement power-up timers
                for (const powerUp in this.activePowerUps) {
                    if (this.activePowerUps[powerUp] > 0) {
                        this.activePowerUps[powerUp]--;
                        
                        // Handle power-up expiration
                        if (this.activePowerUps[powerUp] === 0) {
                            if (powerUp === 'speedBoost') {
                                // Reset speed
                                this.speed = this.initialSpeed * (1 - (this.level - 1) * 0.05);
                                clearInterval(this.gameInterval);
                                this.start();
                            }
                        }
                    }
                }
                
                // Update power-up indicators
                this.updatePowerUpIndicators();
                
                // Randomly generate power-ups with small probability
                if (Math.random() < 0.005 && this.powerUps.length < 2) {
                    this.generatePowerUp();
                }
            }
            
            updatePowerUpIndicators() {
                // Update power-up icons
                this.speedBoostIcon.classList.toggle('active', this.activePowerUps.speedBoost > 0);
                this.shieldIcon.classList.toggle('active', this.activePowerUps.shield > 0);
                this.ghostIcon.classList.toggle('active', this.activePowerUps.ghost > 0);
                this.shrinkIcon.classList.toggle('active', this.activePowerUps.shrink > 0);
                
                // Display timer for active power-ups
                let activePowerUp = null;
                let maxTime = 0;
                
                for (const powerUp in this.activePowerUps) {
                    if (this.activePowerUps[powerUp] > maxTime) {
                        maxTime = this.activePowerUps[powerUp];
                        activePowerUp = powerUp;
                    }
                }
                
                if (activePowerUp && maxTime > 0) {
                    const seconds = Math.ceil(maxTime / (1000 / this.speed));
                    this.powerupTimer.textContent = `${seconds}s`;
                } else {
                    this.powerupTimer.textContent = '';
                }
            }
            
            activatePowerUp(type) {
                const duration = 100; // Game ticks
                
                switch (type) {
                    case 'speedBoost':
                        this.activePowerUps.speedBoost = duration;
                        // Temporarily increase speed by 50%
                        this.speed = this.speed * 0.67;
                        clearInterval(this.gameInterval);
                        this.start();
                        break;
                    case 'shield':
                        this.activePowerUps.shield = duration;
                        break;
                    case 'ghost':
                        this.activePowerUps.ghost = duration;
                        break;
                    case 'shrink':
                        if (this.snake.length > 5) {
                            // Remove half of the snake's body
                            const newLength = Math.ceil(this.snake.length / 2);
                            this.snake = this.snake.slice(0, newLength);
                        }
                        break;
                }
                
                this.updatePowerUpIndicators();
            }
            
            generateFood() {
                // Get a random position
                let x, y;
                let validPosition = false;
                
                while (!validPosition) {
                    x = Math.floor(Math.random() * this.gridWidth);
                    y = Math.floor(Math.random() * this.gridHeight);
                    
                    // Check if position is not occupied by snake
                    validPosition = true;
                    for (const segment of this.snake) {
                        if (segment.x === x && segment.y === y) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check if position is not occupied by obstacle
                    if (validPosition) {
                        for (const obstacle of this.obstacles) {
                            if (obstacle.x === x && obstacle.y === y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    
                    // Check if position is not occupied by power-up
                    if (validPosition) {
                        for (const powerUp of this.powerUps) {
                            if (powerUp.x === x && powerUp.y === y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                }
                
                this.food = { x, y };
            }
            
            generatePowerUp() {
                const powerUpTypes = ['speedBoost', 'shield', 'ghost', 'shrink'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                // Get a random position
                let x, y;
                let validPosition = false;
                
                while (!validPosition) {
                    x = Math.floor(Math.random() * this.gridWidth);
                    y = Math.floor(Math.random() * this.gridHeight);
                    
                    // Check if position is not occupied by snake
                    validPosition = true;
                    for (const segment of this.snake) {
                        if (segment.x === x && segment.y === y) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check if position is not occupied by food
                    if (validPosition && this.food && this.food.x === x && this.food.y === y) {
                        validPosition = false;
                    }
                    
                    // Check if position is not occupied by obstacle
                    if (validPosition) {
                        for (const obstacle of this.obstacles) {
                            if (obstacle.x === x && obstacle.y === y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                }
                
                this.powerUps.push({ x, y, type });
            }
            
            generateObstacles() {
                this.obstacles = [];
                const obstacleCount = Math.min(this.level * 2, 10); // Max 10 obstacles
                
                for (let i = 0; i < obstacleCount; i++) {
                    let x, y;
                    let validPosition = false;
                    
                    while (!validPosition) {
                        x = Math.floor(Math.random() * this.gridWidth);
                        y = Math.floor(Math.random() * this.gridHeight);
                        
                        // Check if position is not occupied by snake
                        validPosition = true;
                        for (const segment of this.snake) {
                            if (segment.x === x && segment.y === y) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        // Check if position is not occupied by food
                        if (validPosition && this.food && this.food.x === x && this.food.y === y) {
                            validPosition = false;
                        }
                        
                        // Check if position is not already an obstacle
                        if (validPosition) {
                            for (const obstacle of this.obstacles) {
                                if (obstacle.x === x && obstacle.y === y) {
                                    validPosition = false;
                                    break;
                                }
                            }
                        }
                        
                        // Add safe zone around snake head
                        if (validPosition && this.snake.length > 0) {
                            const head = this.snake[0];
                            const safeDistance = 2; // Keep obstacles at least 2 spaces away from head
                            if (Math.abs(x - head.x) <= safeDistance && Math.abs(y - head.y) <= safeDistance) {
                                validPosition = false;
                            }
                        }
                    }
                    
                    this.obstacles.push({ x, y });
                }
            }
            
            levelUp() {
                this.level++;
                this.pointsToNextLevel = this.level * 10;
                
                // Increase speed by 5% per level (capped at 50% increase)
                this.speed = this.initialSpeed * (1 - Math.min((this.level - 1) * 0.05, 0.5));
                this.speedElement.textContent = `${(this.initialSpeed / this.speed).toFixed(1)}x`;
                
                // Generate new obstacles
                this.generateObstacles();
                
                // Update level display
                this.levelElement.textContent = this.level;
                
                // Clear existing power-ups
                this.powerUps = [];
                
                // Reset speed if speed boost was active
                if (this.activePowerUps.speedBoost > 0) {
                    this.activePowerUps.speedBoost = 0;
                    clearInterval(this.gameInterval);
                    this.start();
                }
            }
            
            adjustDifficulty() {
                switch (this.difficulty) {
                    case 'easy':
                        this.initialSpeed = 200;
                        break;
                    case 'medium':
                        this.initialSpeed = 150;
                        break;
                    case 'hard':
                        this.initialSpeed = 100;
                        break;
                }
                
                this.speed = this.initialSpeed;
                this.speedElement.textContent = '1x';
            }
            
            updateScoreDisplay() {
                this.scoreElement.textContent = this.score;
                
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('snakeHighScore', this.highScore);
                }
                
                this.highScoreElement.textContent = this.highScore;
            }
            gameOver() {
                this.isGameOver = true;
                clearInterval(this.gameInterval);
                this.gameInterval = null;
                
                // Show game over screen
                this.gameOverElement.style.display = 'flex';
                this.finalScoreElement.textContent = `Score: ${this.score}`;
            }
            
            shadeColor(color, percent) {
                // Helper function to shade colors
                let R = parseInt(color.substring(1,3), 16);
                let G = parseInt(color.substring(3,5), 16);
                let B = parseInt(color.substring(5,7), 16);

                R = parseInt(R * percent);
                G = parseInt(G * percent);
                B = parseInt(B * percent);

                R = (R<255)?R:255;  
                G = (G<255)?G:255;  
                B = (B<255)?B:255;  

                const RR = ((R.toString(16).length===1)?"0"+R.toString(16):R.toString(16));
                const GG = ((G.toString(16).length===1)?"0"+G.toString(16):G.toString(16));
                const BB = ((B.toString(16).length===1)?"0"+B.toString(16):B.toString(16));

                return "#"+RR+GG+BB;
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw snake
                for (let i = 0; i < this.snake.length; i++) {
                    const segment = this.snake[i];
                    
                    // Head is slightly different
                    if (i === 0) {
                        this.ctx.fillStyle = this.snakeColor;
                    } else {
                        // Create a gradient from head to tail
                        const shade = 1 - (i / this.snake.length * 0.5);
                        this.ctx.fillStyle = this.shadeColor(this.snakeColor, shade);
                    }
                    
                    this.ctx.fillRect(
                        segment.x * this.gridSize,
                        segment.y * this.gridSize,
                        this.gridSize,
                        this.gridSize
                    );
                    
                    // Draw eyes on the head
                    if (i === 0) {
                        this.ctx.fillStyle = 'white';
                        
                        const eyeSize = this.gridSize / 5;
                        const eyeOffset = this.gridSize / 3;
                        
                        // Position eyes based on direction
                        let eyeX1, eyeY1, eyeX2, eyeY2;
                        
                        switch (this.direction) {
                            case 'up':
                                eyeX1 = segment.x * this.gridSize + eyeOffset;
                                eyeY1 = segment.y * this.gridSize + eyeOffset;
                                eyeX2 = segment.x * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                eyeY2 = segment.y * this.gridSize + eyeOffset;
                                break;
                            case 'down':
                                eyeX1 = segment.x * this.gridSize + eyeOffset;
                                eyeY1 = segment.y * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                eyeX2 = segment.x * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                eyeY2 = segment.y * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                break;
                            case 'left':
                                eyeX1 = segment.x * this.gridSize + eyeOffset;
                                eyeY1 = segment.y * this.gridSize + eyeOffset;
                                eyeX2 = segment.x * this.gridSize + eyeOffset;
                                eyeY2 = segment.y * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                break;
                            case 'right':
                                eyeX1 = segment.x * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                eyeY1 = segment.y * this.gridSize + eyeOffset;
                                eyeX2 = segment.x * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                eyeY2 = segment.y * this.gridSize + this.gridSize - eyeOffset - eyeSize;
                                break;
                        }
                        
                        this.ctx.fillRect(eyeX1, eyeY1, eyeSize, eyeSize);
                        this.ctx.fillRect(eyeX2, eyeY2, eyeSize, eyeSize);
                    }
                }
                
                // Draw food
                if (this.food) {
                    this.ctx.fillStyle = this.foodColor;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.food.x * this.gridSize + this.gridSize / 2,
                        this.food.y * this.gridSize + this.gridSize / 2,
                        this.gridSize / 2,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                    
                    // Add shine to the food
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.food.x * this.gridSize + this.gridSize / 3,
                        this.food.y * this.gridSize + this.gridSize / 3,
                        this.gridSize / 6,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
                
                // Draw obstacles
                this.ctx.fillStyle = '#555';
                for (const obstacle of this.obstacles) {
                    this.ctx.fillRect(
                        obstacle.x * this.gridSize,
                        obstacle.y * this.gridSize,
                        this.gridSize,
                        this.gridSize
                    );
                }
                
                // Draw power-ups
                for (const powerUp of this.powerUps) {
                    let color;
                    switch (powerUp.type) {
                        case 'speedBoost':
                            color = '#1E90FF'; // Blue
                            break;
                        case 'shield':
                            color = '#FFD700'; // Gold
                            break;
                        case 'ghost':
                            color = '#9370DB'; // Purple
                            break;
                        case 'shrink':
                            color = '#FF6347'; // Tomato
                            break;
                    }
                    
                    // Draw power-up as diamond
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(powerUp.x * this.gridSize + this.gridSize / 2, powerUp.y * this.gridSize);
                    this.ctx.lineTo(powerUp.x * this.gridSize + this.gridSize, powerUp.y * this.gridSize + this.gridSize / 2);
                    this.ctx.lineTo(powerUp.x * this.gridSize + this.gridSize / 2, powerUp.y * this.gridSize + this.gridSize);
                    this.ctx.lineTo(powerUp.x * this.gridSize, powerUp.y * this.gridSize + this.gridSize / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Add pulsing effect
                    const time = Date.now() / 200;
                    const pulse = (Math.sin(time) + 1) / 4;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(powerUp.x * this.gridSize + this.gridSize / 2, powerUp.y * this.gridSize + this.gridSize / 4);
                    this.ctx.lineTo(powerUp.x * this.gridSize + this.gridSize * 3/4, powerUp.y * this.gridSize + this.gridSize / 2);
                    this.ctx.lineTo(powerUp.x * this.gridSize + this.gridSize / 2, powerUp.y * this.gridSize + this.gridSize * 3/4);
                    this.ctx.lineTo(powerUp.x * this.gridSize + this.gridSize / 4, powerUp.y * this.gridSize + this.gridSize / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                // Draw active power-up effects
                if (this.activePowerUps.ghost > 0) {
                    // Add ghost effect to snake
                    this.ctx.strokeStyle = 'rgba(147, 112, 219, 0.5)';
                    this.ctx.lineWidth = 2;
                    for (const segment of this.snake) {
                        this.ctx.strokeRect(
                            segment.x * this.gridSize,
                            segment.y * this.gridSize,
                            this.gridSize,
                            this.gridSize
                        );
                    }
                }
                
                if (this.activePowerUps.shield > 0) {
                    // Add shield effect around snake head
                    const head = this.snake[0];
                    this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(
                        head.x * this.gridSize + this.gridSize / 2,
                        head.y * this.gridSize + this.gridSize / 2,
                        this.gridSize * 0.75,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.stroke();
                }
            }
        }

        // Initialize the game
        const canvas = document.getElementById('game-canvas');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const restartButton = document.getElementById('restart-button');
        const playAgainButton = document.getElementById('play-again');
        const difficultySelect = document.getElementById('difficulty');
        const snakeColorInput = document.getElementById('snake-color');
        const foodColorInput = document.getElementById('food-color');
        const helpButton = document.getElementById('help-button');
        const closeHelpButton = document.getElementById('close-help');
        const helpModal = document.getElementById('help-modal');
        
        // Mobile controls
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        
        // Set canvas size
        canvas.width = 600;
        canvas.height = 400;
        
        // Create game instance
        let game = new Snake(canvas, {
            difficulty: difficultySelect.value,
            snakeColor: snakeColorInput.value,
            foodColor: foodColorInput.value
        });
        
        // Event listeners
        startButton.addEventListener('click', function() {
            if (game.isGameOver) {
                game = new Snake(canvas, {
                    difficulty: difficultySelect.value,
                    snakeColor: snakeColorInput.value,
                    foodColor: foodColorInput.value
                });
            }
            game.start();
            this.blur();
        });
        
        pauseButton.addEventListener('click', function() {
            const isPaused = game.pause();
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            this.blur();
        });
        
        restartButton.addEventListener('click', function() {
            game = new Snake(canvas, {
                difficulty: difficultySelect.value,
                snakeColor: snakeColorInput.value,
                foodColor: foodColorInput.value
            });
            game.start();
        });
        
        playAgainButton.addEventListener('click', function() {
            game = new Snake(canvas, {
                difficulty: difficultySelect.value,
                snakeColor: snakeColorInput.value,
                foodColor: foodColorInput.value
            });
            game.start();
            game.gameOverElement.style.display = 'none';
        });
        
        difficultySelect.addEventListener('change', function() {
            game.difficulty = this.value;
            game.adjustDifficulty();
            if (game.gameInterval) {
                clearInterval(game.gameInterval);
                game.start();
            }
        });
        
        snakeColorInput.addEventListener('input', function() {
            game.snakeColor = this.value;
        });
        
        foodColorInput.addEventListener('input', function() {
            game.foodColor = this.value;
        });
        
        helpButton.addEventListener('click', function() {
            helpModal.style.display = 'flex';
        });
        
        closeHelpButton.addEventListener('click', function() {
            helpModal.style.display = 'none';
        });
        
        helpModal.addEventListener('click', function(e) {
            if (e.target === helpModal) {
                helpModal.style.display = 'none';
            }
        });
        
        // Mobile controls
        upButton.addEventListener('click', function() {
            if (game.direction !== 'down') {
                game.nextDirection = 'up';
            }
        });
        
        downButton.addEventListener('click', function() {
            if (game.direction !== 'up') {
                game.nextDirection = 'down';
            }
        });
        
        leftButton.addEventListener('click', function() {
            if (game.direction !== 'right') {
                game.nextDirection = 'left';
            }
        });
        
        rightButton.addEventListener('click', function() {
            if (game.direction !== 'left') {
                game.nextDirection = 'right';
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (game.direction !== 'down') {
                        game.nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (game.direction !== 'up') {
                        game.nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (game.direction !== 'right') {
                        game.nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (game.direction !== 'left') {
                        game.nextDirection = 'right';
                    }
                    break;
                case ' ':
                    const isPaused = game.pause();
                    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
                    break;
                case 'r':
                case 'R':
                    game = new Snake(canvas, {
                        difficulty: difficultySelect.value,
                        snakeColor: snakeColorInput.value,
                        foodColor: foodColorInput.value
                    });
                    game.start();
                    break;
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            // Maintain aspect ratio for canvas
            const container = document.querySelector('.game-container');
            const containerWidth = container.clientWidth;
            const aspectRatio = canvas.width / canvas.height;
            
            if (containerWidth < canvas.width) {
                canvas.style.width = '100%';
                canvas.style.height = (containerWidth / aspectRatio) + 'px';
            } else {
                canvas.style.width = canvas.width + 'px';
                canvas.style.height = canvas.height + 'px';
            }
        });
        
        // Initial resize
        window.dispatchEvent(new Event('resize'));
    });
</script>
</body>
</html>
